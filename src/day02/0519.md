22.05.19

DataType

앞으로는 데이터의 타입뿐만 아니라 데이터의 크기도 중요하다!

n진법은 0부터 n~1의 다음 숫자는 10이 됨.
16의 경우는 10이 한번 더 나오기 때문에
(A, B, C, D, E, F)

String은 문자타입이 맞지만!!! 문자타입의 기본형태는 Char다.

리터럴 : 메모리 어딘가에 저장되긴 하는데 이름을 따로 붙여주기 않았기 때문에 찾아올 수는 없음.
ex: int n = 30 + 40; 
    이 때! 30, 40은 리터럴값이다. 정수 리터럴!

byte x = 3; 이라고 했을 때
x의 타입은 byte이나, 3의 타입은 int다.
why? x에 들어가기 전에 먼저 잡히기 때문에!!(이게 리터럴이다.) 


기본 데이터 타입에서의 문제 : 실수 연산에서 소수점 자리 오차가 발생할 가능성이 있다.

long d = 2147483648L; // 2147483648이 왜 에러..? long은 900경까지 저장된다매
// why? : 2147483648 리터럴 자체는 int로 된다.
// 범위가 int 범위를 넘어가기 때문에 리터럴 자체가 안된 상태.
// 이럴 땐 리터럴 하려는 값 뒤에 L을 붙여주면 된다.

float f1 = 1.2345678901234F; // 4byte 할당

실수 부분에서는 그냥 덮어놓고!! double만 써라.


JAVA에선,JS랑 다르게 정확히 true, false 아니면 안됨!!


c언어는 논리타입이 없어서 0과 1을 활용
0이면 false고 1이면 true


단일!문자타입
char c1 = 'A'; // 한 글자만 저장할 때 무조건 홑따옴표!!
// 2글자 이상이면 쌍따옴표!!
char c2 = 44032; 이러면 '가' 나옴
System.out.println("c2 = " + c2);
65는 대문자 A, 97은 소문자 a


문자열 타입
String 기본 타입이 아니다. 객체다. char 배열이 들어있다고 보면 됨.
String s1 = "hello"; // char가 5개 필요
String s2 = "hello java"; // 10글자임(공백 포함) char가 10개 필요


// 문자 + 숫자 = 문자다.
System.out.println(s1 + 300 + 120);
 ㄴ hello300120으로 나옴.
===============================================

* 중요!!!!
형 변환(type casting)

promotion (승격)
byte a = 100; // 1byte 할당

int b = a; // 에러는 안나지만 엄청난 오류가 있다. why????
            // a가 int로 자동 형 변환되었기 때문!!! JAVA 가상 머신이 해준다.(묵시적 형변환)

double c = b; // b가 double로 자동 형 변환됨.
System.out.println("c = " + c);

* 묵시적 형변환은!! 그렇게 해도 전혀 문제가 없을 때 된다고 보면 된다.
* 데이터 크기가 작은 쪽에서 큰 쪽으로의 변환은 묵시적 형변환이 일어남.
* 넓은 곳으로 이사가면 있는거 다 들고 가도 문제가 되지 않으나 넓은 곳에서 작은 곳으로 이사가면 버려야 하기 때문!!


* 실수는 무조건 정수보다 표현 범위가 넓기 때문에 정수보다 실수가 항상 데이터 크기가 크다고 알면 된다.
ex) 0과 1 사이의 정수는 있냐? 없다
   그럼, 0과 1 사이의 실수는? 0.1, 0.01, 0.001 개많다..

==========================

// downcasting : 하위 타입 변환
// 다운 캐스팅시 값의 손실이 일어날 수 있음. 매번 일어나는 것은 아니고 일어날 가능성이 있다!!

    // 0011 1110 1000 이게 1000을 2진수로 바꾼 결과!
    // 0011 부분이 byte로 바뀌면서 소실됨!! 그럼 1110 1000을 가져오는데
    // 맨 앞 부분이 부호 표시임. 0이면 양수, 1이면 음수.
int n = 1000; // 만약 1000이 아니라 100이었다면 값 손실이 없었을것!!
byte m = (byte) n; // n은 int 넓은 곳에서 좁은 곳을 가려는 행위인거임. 내가 직접 버릴 것들을 버려줘야함.

System.out.println("m = " + m); // 왜 결과가 -24???


* 일부러 명시적 형변환을 사용하는 경우
ex : double k = 5.556;
  int j = (int) k; // 실수가 무조건 정수보다 크기 때문에 이것도 큰 곳에서 작은 곳으로 이사하려는 것임. 이러면 알아서 변환하지 않고 내가 처리해주길 기다림.
  System.out.println("j = " + j); // 소수점 이하가 날아감! 이럴 땐 일부러 명시적 형변환을 사용하기도 한다.

* (int), (byte)이런 명시적 형변환을 위해 써줄 때! 얘네를 형변환 연산자라고 지칭함.(단항 연산자!)

=========================

// 타입이 다른 데이터의 연산에서는
// 작은 쪽을 큰 쪽으로 변환한 후 연산을 진행.
int a = 10;
short b = 30;
int c = a + b; // 이 경우 자바 가상에서 a + (int) b;를 알아서 한 것!!

        char d = 'A'; // 2byte 컴퓨터는 얘를 65로 알고 있다.
        int e = 100; // 4byte
        System.out.println(d + e); // 결과는 165


* 주의!!
* 문자열(String) + 숫자 = 문자열.
* 단일 문자(char) + 숫자 = 숫자.

        char f = (char) (d + e); // d+e는 int라서 다운 캐스팅 해야함.
        System.out.println("f = " + f); // 165에 해당하는 단일문자(¥) 반환

        System.out.println(3.0 + 5); // 8.0이 나옴.

        byte b1 = 100;
        byte b2 = 20;

        int result = b1 * b2; // 둘이 더한게 120인데도 안된다고 하네???
        // 여기서 byte result =로 시도했었음.. 근데 안됨. 왜??? 둘이 더한게 int라는데?? why??
        /*
            int보다 작은 데이터 (byte, short, char)
            끼리의 연산은 결과가 자동으로 int로 변환되어 처리.(자바가 자동으로 안전장치를 넣는다.)
                자바 왈: 조그만 애들끼리 연산(덧셈뿐만 아니라 곱셈의 경우에도)을 하다보면
                        금방 너무 커져버릴 위험이 있는데?? 그럼 애초에 int로 해줄게.
            (스택 오버플로우, 언더플로우 방지)
        */

        System.out.println('A' + 'B'); // 결과 131이 나옴.
                                    //int보다 작은 애들끼리의 연산이기 때문에 자동 int로 변환되었기 때문!!
        System.out.println("A" + "B"); // AB가 나옴.

===========================

4강 연산자.

산술연산자에서 그동안 알던 ** 제곱 연산자는 없다.
관계연산자에서 = = = 이런거 없다.

=======
논리연산자 &&, || 이건 단축 연산!!


단축연산은 좌항만 봤을 때 거기서부터 논리연산이 판가름 나버리면
그 이후 연산은 무시!
 ㄴ 실행 자체를 하지 않음.
&, | 하나짜리는 좌, 우항 다 보긴 함.


학력요건, 자소서 중에 학력요건을 먼저 봤더니 통과를 못했네?
그럼 내가 자소서를 굳이 봐야하니? nope!

========

// 비트 연산자
byte a = 5; // 0000 0101
byte b = 3; // 0000 0011 1byte는 8bit

        // 피연산자가 정수라서 비트연산자 역할을 함.
        // & (비트곱) : 각 비트 자리수를 곱하세요.
        System.out.println(a & b); // 1 why?? 0000 0001이 되기 때문!

        // | (비트합) : 각 비트 자리수를 더하세요. 단 1+1=1로 처리
        System.out.println(a | b); // 7 0000 0111이 되기 때문!

        // ^ (배타적 논리합) : 각 비트 자리수를 비교해서 다르면 1 같으면 0
        System.out.println(a ^ b); // 6 0000 0110이 되기 때문!

        // 비트 이동 연산
        // << n : 왼쪽으로 이동 -> 2의 n제곱으로 곱해라. 
        // >> n : 오른쪽으로 이동 -> 2의 n제곱으로 나눠라.

int x = 192;
System.out.println(x << 3); // 1536 어케 나온 숫자?? 192 * 2의 3제곱 = 1536
System.out.println(x >> 2); // 48 어케 나온 숫자?? 192 / 2의 2제곱 = 48

===================

RandomExample
(연산자 우선순위 내용 포함)

/ 난수 생성
double rn = Math.random(); // 0.0 ~ 1.0 미만의 양수의 실수들을 리턴하기 때문.
System.out.println("rn = " + rn);

        // 1이상 10이하의 랜덤 정수를 받고 싶을 땐??
        /*
            Math.random()                   -> 0.0 <= ~ < 1.0
            Math.random() * 10              -> 0.0 <= ~ < 10.0
            (int) (Math.random() * 10)      -> 0 <= ~ < 10  0부터 9까지
            (int) (Math.random() * 10) +1   -> 1 <= ~ < 11  1부터 10까지
        */
        int num = (int) (Math.random() * 10) +1;
//        int num2 = (int) Math.random() * 10 +1;
//                  이러면 영원히 1만 나옴 우선순위에 따라서! (int)는 형 변환하라는 단항연산자!
        System.out.println("num = " + num);

==============================================

표준 입출력

String dog = "멍멍이", cat = "야옹이";

        System.out.print(dog);
        System.out.println(cat);

        //System.out.print(dog);
        //System.out.print(cat);
        // 이러면 "멍멍이야옹이" 이렇게 나옴

        int month = 7;
        int day = 17;
        String anniversary = "제헌절";

        System.out.println(month + "월 "
                + day + "일은 "
                + anniversary + "입니다.");

        // 포맷 문자 형식
        // %d: 10진수 정수, %f: 실수, $s: 문자열, $c: 단일문자
        System.out.printf("%d월 %d일은 %s입니다.\n", month, day, anniversary);
        System.out.println(dog);

    System.out.printf("%d월 %d일은 %s입니다.\n", month, day);
        // ㄴ %는 3개 줘놓고 month, day 등 인수를 2개만 주면 에러난다.
        // %는 3개인데 인수를 더 많이 주면?? 정상 실행된다.
        // %d라고 해놓고 문자열을 줘버리면??? 에러난다.

* 에러나면 에러 첫줄이 제일 중요!!
* 정 모르겠으면 구글에 첫줄 복붙해봐라.

// %f: 강제로 소수점 6자리를 표현합니다.
double rate = 25.45678901234;

System.out.printf("비율은 %f입니다.\n", rate); // 이랬더니 25.456789 이라고 나오네

System.out.printf("비율은 %.4f입니다.\n", rate); // 이랬더니 25.4567 이라고 나오네

System.out.printf("비율은 %.2f입니다.\n", rate); // 이랬더니 25.45 이라고 나오네

System.out.printf("비율은 %.2f%입니다.\n", rate); // 이랬더니 오류남. %입이 뭐냐고 묻다니..

System.out.printf("\\비율은 %.2f%%입니다.\n", rate); // 이래야 뒤에 %입니다.라고 제대로 나옴.

=======================

입력!!

//        System.in.read(); // 이랬더니 종료됐다는 코드가 뜨지 않고 눌러보면 깜빡이며 입력할 수 있는 부분이 나옴.
// 입력값을 변수에 담아서 쓰려고 했는데...

//        int inputData = System.in.read();
//        System.out.println(inputData);

        // 스캐너 api 사용
        Scanner sc = new Scanner(System.in); // main처럼 입력을 받고 싶으면 무조건 앞에 써라.

        // 스캐너의 함수들
        /*
            - next(): 문자열을 입력받을 때, 공백은 처리불가.
            - nextLine(): 문자열 입력, 공백 포함 가능.
            - nextInt() : 정수를 입력.
            - nextDouble(): 실수를 입력.
         */

String name = sc.next(); // 공백처리를 못함. 공백 발생 이전까지만 입력 받음.

System.out.print("이름: "); // 출력문을 따로 위에 적는다. JS에서랑 다름.

String name = sc.nextLine();// 공백까지 입력받을 수 있음.

System.out.println("name = " + name);

        System.out.print("나이: ");
        int age = sc.nextInt();
        System.out.println("age + 10 = " + (age + 10));

