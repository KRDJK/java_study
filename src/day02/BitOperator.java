package day02;

public class BitOperator {

    public static void main(String[] args) {

        // 비트 연산자
        byte a = 5; // 0000 0101
        byte b = 3; // 0000 0011 1byte는 8bit

        // 피연산자가 정수라서 비트연산자 역할을 함.
        // & (비트곱) : 각 비트 자리수를 곱하세요.
        System.out.println(a & b); // 1 why?? 0000 0001이 되기 때문!

        // | (비트합) : 각 비트 자리수를 더하세요. 단 1+1=1로 처리
        System.out.println(a | b); // 7 0000 0111이 되기 때문!

        // ^ (배타적 논리합) : 각 비트 자리수를 비교해서 다르면 1 같으면 0
        System.out.println(a ^ b); // 6 0000 0110이 되기 때문!


        // 비트 이동 연산
        // << : 왼쪽으로 이동 -> 2의 이동숫자만큼 제곱으로 곱해라. 무슨 말..??
        // >> : 오른쪽으로 이동 -> 2의 이동숫자만큼 제곱으로 나눠라.

        // x는 int니까 4byte를 차지. 192를 2진수로 변환하면 00000000 00000000 00000000 11000000
        int x = 192;
        // 00000000 00000000 00000110 00000000
        System.out.println(x << 3); // 1536 어케 나온 숫자?? 192 * 2의 3제곱 = 1536
        // 00000000 00000000 00000000 00110000
        System.out.println(x >> 2); // 48 어케 나온 숫자?? 192 / 2의 2제곱 = 48


        // 비트 반전 연산자 (~)
        int y = 8;              // 0000 1000
        System.out.println(~y); // 1111 0111 
                                // 일단 맨 앞이 1이라 음수
                                // 1의 보수 x000 1000
                                // 2의 보수 x000 1001
    }

}
